## 缓存逻辑梳理

* `Expires`: 特定时间
* `Cache-Control`: `max-age`,相对于请求时间一个资源被考虑为新鲜的最大时间

强制缓存：不会缓存`index.html`
> 如果设置`Expires`在指定时间后便不再缓存

1. 客户端请求，服务端会设置`Cache-Control`请求头告诉客户端，在指定时间内从缓存中查找内容，不要再向服务端发起请求
2. 客户端在收到响应头后，指定时间内从缓存中查找内容
3. 如果是10s后，重复步骤1

协商缓存一：
> 这里服务端也会检测`index.html`的修改时间有没有发生变化，如果没有变化的也会返回304让浏览器从缓存中查找

1. 客户端请求，服务端会设置`Expires`,`Cache-Control`请求头，并且通过`Last-Modified`
   请求头表示缓存文件的最后一次更改时间，通知客户端在指定时间内从缓存中查找内容，不要再向服务端发起请求。并且此后客户端每次发请求时都会携带`If-Modified-Since`请求头，它的值为`Last-Modified`
   响应头的值，表示缓存文件的最近一次更改时间
2. 客户端在收到响应头后，10s内从缓存中查找内容，不再发起请求
3. 10s后，服务端再次收到请求，此时会用文件最新的修改时间与`If-Modified-Since`
   携带的请求头对应的时间作对比，如果相同，说明文件没有发生变化，返回304状态码，浏览器继续读取缓存内容。如果不相同，直接读取最新文件返回即可。

缺陷：

1. `Last-Modified`设置的时间是以秒为单位的
2. 文件没有发生改变(修改某一个内容，再改回来)，但是修改时间发生了变化，也会导致缓存失效

协商缓存二：

1. 设置唯一的`Etag`标识：为文件生成唯一的`md5`字符串，并设置`Etag`响应头，内容为文件的唯一标识
2. 客户端在每次请求时都会通过`If-None-Match`请求头来携带设置的`Etag`，服务端会用请求文件当前对应的`Etag`和旧的`Etag`进行比对

缺陷：

* 请求每次还会读取文件并生成摘要，当文件过大时会出现问题
